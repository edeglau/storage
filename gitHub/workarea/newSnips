from pymel.core import *
selection=ls(sl=1)
for each in selection:
    print each.numCVs()
    print each.length(tolerance=0.001)
    for item in each.numCVs():
        makepoint= each.getCVs(item, space='preTransform')
    print makepoint
        print each.getParamAtPoint(item, space='preTransform')

    
    for eachNumber, eachItem in enumerate(each.cv):  
        print each.getDerivativesAtParm(eachNumber, space='preTransform')
    for eachNumber, eachItem in enumerate(each.cv):
        makepoint= each.getCV(eachNumber, space='preTransform')
        print makepoint
        
        
        
        print makepoint
        print each.getParamAtPoint(makepoint, space='preTransform')
        
from pymel.core import *
getit=ls(sl=1, fl=1)
for each in getit:
    delete(each.cv[1])
    
from pymel.core import *
getit=ls(sl=1, fl=1)
for each in getit:
    for item in each.cv[::2]
        delete(item)

from pymel.core import *
getit=ls(sl=1, fl=1)
if nodeType(each)=="transform":
    for each in getit:
        for item in each.cv[::2]:
            delete(item)
elif nodeType(each)=="nurbsCurve":
    for each in getit[::2]:
        delete(each)
        
        
cmds.undoInfo(state=1)


from pymel.core import *
sys.path.append(str('//usr//people//elise-d//workspace//sandBox//rigModules//'))
import baseFunctions_maya
reload (baseFunctions_maya)
getClass=baseFunctions_maya.BaseClass()
getSel=cmds.ls(sl=1, fl=1)
parentObj=getSel[0]
for each in getSel[1:]:
    getTranslation, getRotation=getClass.locationXForm(each)
    newObj=cmds.duplicate(parentObj)
    cmds.xform(newObj, ws=1, t=getTranslation)
    cmds.xform(newObj, ws=1, ro=getRotation)


nedit ~/config/env.csh

filepath="/usr/people/elise-d/workspace/techAnimTools/python/src/utils/"
sys.path.append(str(filepath))
import deformerControl
reload (deformerControl)
getClass=deformerControl.DeformerControl()    

exec(open('/usr/people/elise-d/workspace/techAnimTools/personal/elise-d/rigModules/RigToolKit.py'))
ToolKitUI()


secondpart=cmds.ls(sl=1)
BucketValue=[]
firstMinValue=.5
firstMaxValue=5.0
percentTop=firstMaxValue*100
print percentTop
getPercentile=percentTop/len(secondpart)            
for key, value in enumerate(secondpart):
    percValue= (key+1)*getPercentile*.01
    BucketValue.append(percValue)

for each in range(len(BucketValue)):
    getNewVal=BucketValue[each]
    print getNewVal
    
#        def frange(start, stop, step):
#            i = start
#            while i < stop:
#                yield i
#                i += step
#        for i in frange(firstMinValue, firstMaxValue, step):
#            print(i)  

selall=cmds.ls(sl=1)
for each in selall:
    cmds.setAttr(each+".selfCollide", 1)

selall=cmds.ls(sl=1)
for each in selall:
    cmds.setAttr(each+".maxIterations", 10000)

selall=cmds.ls(sl=1)
for each in selall:
    cmds.setAttr(each+".maxIterations", 3)

selall=cmds.ls(sl=1)
for each in selall:
    cmds.setAttr(each+".selfCollisionFlag", 2)


selall=cmds.ls(sl=1)
for each in selall:
    cmds.setAttr(each+".pointMass", 0.2)
    
#        for key, value in enumerate(getSeln):#reference the mid list length to append the incremented value to bucket
#            percValue= (key+1)*getPercentile*.01
#            BucketValue.append(percValue)


from statistics import median
getMesh=cmds.ls(sl=1)
for each in getMesh:
    transform=cmds.xform(getMesh[0], q=True, ws=1, t=True) 
    print len(transform)
    print transform[0::3]
    print transform[1::3]
    print median(transform[2::3])  
    for each in transform:
        print each
        
        
from pymel.core import *
getSel=ls(sl=1, fl=1)
for each in getSel:
    for item in each.vtx:
        print item.getPosition()
        
        
        
from pymel.core import *
getit=ls(sl=1, fl=1)
print getit[1:]
for each in getit[:-1]:
    for item in each.cv[0]:
        mypos=item.getPosition()
print mypos[0]
xform(getit[1:], ws=1, t=mypos)  



from pymel.core import *
getit=ls(sl=1, fl=1)
for eachctrl in xrange(len(getit) - 1):
    for each in getit:
        current_item, next_item, previous_item= getit[eachctrl], getit[eachctrl + 1], getit[eachctrl - 1]
        print current_item, next_item, previous_item
        select(current_item, r=1)
        if each!=current_item:
            select(each, add=1)
        else:
            pass
        cmds.CutCurve()      
        
        
from pymel.core import *
getit=ls(sl=1, fl=1)
for eachCurve in getit:
    for each in range(len(getit)):
        if getit[each]!=eachCurve:
            select(eachCurve, r=1)
            select(getit[each], add=1)
            cmds.CutCurve()
        else:
            print getit[each]+" matches and skipped"     
            
            
            
            
create a scriptNode:

myscriptNode=cmds.scriptNode(n="selectionScript", st=2, stp="python", bs=myScriptJobEvent)


put this in the expression:

def myScriptJobEvent():
    getObj=cmds.ls(sl=1)
    if getObj:
        if "pCone1" in getObj[0]:
            cmds.select("nurbsSphere1")
        else:
            return

getThisScript=cmds.scriptJob( e=["SelectionChanged", "myScriptJobEvent()"])



def myScriptJobEvent():
    from pymel.core import *
    getObj=ls("nParticleShape1")
    getValue=getattr(getObj[0],"lifespanPP").get()
    emitCount=30
    if getValue>10:
        emitCmd=emit("exploP", o="object")
        for each in range(emitCount):
            getPos=each.getPosition
            cmds.emit( object='particle1', pos=getPos, attribute=('lifespanPP'), floatValue=.5)

getThisScript=cmds.scriptJob( e=[myScriptJobEvent()])     


nurbsToPoly(newItem[0], mnd=1  ,ch=1 ,f=1 ,pt=1 ,pc=200 ,chr=0.9 ,ft=0.01 ,mel=0.001 ,d=0.1 ,ut=1 ,un=3 ,vt=1 ,vn=3 ,uch=0 ,ucr=0 ,cht=0.2 ,es=0 ,ntr=0 ,mrt=0 ,uss=1)


from pymel.core import *
def median_find(lst):
    even = (0 if len(lst) % 2 else 1) + 1
    half = (len(lst) - 1) / 2
    mysum= sum(sorted(lst)[half:half + even]) / float(even)
    print mysum    
getit=ls(sl=1, fl=1)
TheseFaces=getit[0].faces
posBucket=[]
for each in TheseFaces[0]:
    select(TheseFaces[0], r=1)
    getItems=cmds.polyListComponentConversion( ff=1, tv=1 )
    cmds.select(getItems)
    getItems=ls(sl=1, fl=1)
for each in getItems:
    transform=each.getPosition()
    posBucket.append(median_find(transform[0::3]))
    posBucket.append(median_find(transform[1::3]))
    posBucket.append(median_find(transform[2::3]))
    
    
from pymel.core import *
def median_find(lst):
    even = (0 if len(lst) % 2 else 1) + 1
    half = (len(lst) - 1) / 2
    mysum= sum(sorted(lst)[half:half + even]) / float(even)
    return mysum
getit=ls(sl=1, fl=1)
moveTool=ls(getit[1])
intersector=ls(getit[2])
TheseFaces=getit[0].faces
posBucket=[]
getFace=TheseFaces[2]
for each in getFace:
    select(getFace, r=1)
    getItems=cmds.polyListComponentConversion( ff=1, tv=1 )
    cmds.select(getItems)
    getItems=ls(sl=1, fl=1)
findTransformX=[]
findTransformY=[]
findTransformZ=[] 
for each in getItems:
    transform=xform(each, q=1, ws=1, t=1)
    print transform
    findTransformX.append(transform[0])
    findTransformY.append(transform[1])
    findTransformZ.append(transform[2])
getX=median_find(findTransformX)
getY=median_find(findTransformY)
getZ=median_find(findTransformZ)+1
newnumbers=[getX, getY, getZ]   
print newnumbers
cmds.xform(moveTool, ws=1, t=(newnumbers[0], newnumbers[1], newnumbers[2]))
print newnumbers
printget=getit[0].intersect(newnumbers, 2, tolerance=1e-10, space='object')
print printget





import sys
import maya.cmds as cmds
import maya.OpenMaya as OpenMaya
import maya.OpenMayaMPx as OpenMayaMPx

kPluginCmdName = "mayaPythonCornellBox"

def findMeshIntersection( meshName, raySource, rayDir):
    #       Create an empty selection list. 
    selectionList = OpenMaya.MSelectionList() 
    #       Put the mesh's name on the selection list. 
    selectionList.add(meshName) 
    #       Create an empty MDagPath object. 
    meshPath = OpenMaya.MDagPath()
    #       Get the first item on the selection list (which will be our mesh) 
    #       as an MDagPath. 
    selectionList.getDagPath(0, meshPath)
    #       Create an MFnMesh functionset to operate on the node pointed to by 
    #       the dag path. 
    meshFn = OpenMaya.MFnMesh(meshPath) 
    #       Convert the 'raySource' parameter into an MFloatPoint. 
    raySource = OpenMaya.MFloatPoint(raySource[0], raySource[1], raySource[2]) 
    #       Convert the 'rayDir' parameter into an MVector.` 
    rayDirection = OpenMaya.MFloatVector(rayDir[0], rayDir[1], rayDir[2]) 
    #       Create an empty MFloatPoint to receive the hit point from the call. 
    hitPoint = OpenMaya.MFloatPoint() 
    #       Set up a variable for each remaining parameter in the 
    #       MFnMesh::closestIntersection call. We could have supplied these as 
    #       literal values in the call, but this makes the example more readable. 
    sortIds = False 
    maxDist = 10.0 
    bothDirections = False 
    noFaceIds = None 
    noTriangleIds = None 
    noAccelerator = None
    noHitParam = None 
    noHitFace = None 
    noHitTriangle = None 
    noHitBary1 = None 
    noHitBary2 = None 
    #       Get the closest intersection. 
    gotHit = meshFn.closestIntersection( 
        raySource, rayDirection, 
        noFaceIds, noTriangleIds, 
        sortIds, OpenMaya.MSpace.kWorld, maxDist, bothDirections, 
        noAccelerator, 
        hitPoint, 
        noHitParam, noHitFace, noHitTriangle, noHitBary1, noHitBary2 
    ) 
    #       Return the intersection as a Pthon list. 
    if gotHit:
        print 'O'
        sys.stderr.write( "Intersection: (%f, %f, %f)\n" % (hitPoint.x, hitPoint.y, hitPoint.z))
        return [hitPoint.x, hitPoint.y, hitPoint.z] 
    else: 
        print 'X'
        return None 
    
import maya.OpenMaya as om
    selList = om.MSelection list;

    nodeObject = om.MObject();
    selList.getDependNode(0, nodeObject)

import maya.OpenMaya as om
meshName
raySource=None
rayDir=None
def findMeshIntersection(meshName, raySource, rayDir):
        #        Create an empty selection list.
        selectionList = om.MSelectionList()

        #        Put the mesh's name on the selection list.
        selectionList.add(meshName)

        #        Create an empty MDagPath object.
        meshPath = om.MDagPath()

        #        Get the first item on the selection list (which will be our mesh)
        #        as an MDagPath.
        selectionList.getDagPath(0, meshPath)

        #        Create an MFnMesh functionset to operate on the node pointed to by
        #        the dag path.
        meshFn = om.MFnMesh(meshPath)

        #        Convert the 'raySource' parameter into an MFloatPoint.
        raySource = om.MFloatPoint(raySource[0], raySource[1], raySource[2])

        #        Convert the 'rayDir' parameter into an MVector.`
        rayDirection = om.MFloatVector(rayDir[0], rayDir[1], rayDir[2])

        #        Create an empty MFloatPoint to receive the hit point from the call.
        hitPoint = om.MFloatPoint()

        #        Set up a variable for each remaining parameter in the
        #        MFnMesh::closestIntersection call. We could have supplied these as
        #        literal values in the call, but this makes the example more readable.
        sortIds = False
        maxDist = 10.0
        bothDirections = False
        noFaceIds = None
        noTriangleIds = None
        noAccelerator = None
        noHitParam = None
        noHitFace = None
        noHitTriangle = None
        noHitBary1 = None
        noHitBary2 = None

        #        Get the closest intersection.
        gotHit = meshFn.closestIntersection(
                raySource, rayDirection,
                noFaceIds, noTriangleIds,
                sortIds, om.MSpace.kWorld, maxDist, bothDirections,
                noAccelerator,
                hitPoint,
                noHitParam, noHitFace, noHitTriangle, noHitBary1, noHitBary2
        )

        #        Return the intersection as a Pthon list.
        if gotHit:
                return [hitPoint.x, hitPoint.y, hitPoint.z]
        else:
                return None
            
            
            
import maya.OpenMaya as om

from pymel.core import *


def findMeshIntersection(meshName, raySource, rayDir):
        #        Create an empty selection list.
        selectionList = om.MSelectionList()

        #        Put the mesh's name on the selection list.
        selectionList.add(meshName)

        #        Create an empty MDagPath object.
        meshPath = om.MDagPath()

        #        Get the first item on the selection list (which will be our mesh)
        #        as an MDagPath.
        selectionList.getDagPath(0, meshPath)

        #        Create an MFnMesh functionset to operate on the node pointed to by
        #        the dag path.
        meshFn = om.MFnMesh(meshPath)

        #        Convert the 'raySource' parameter into an MFloatPoint.
        raySource = om.MFloatPoint(raySource[0], raySource[1], raySource[2])

        #        Convert the 'rayDir' parameter into an MVector.`
        rayDirection = om.MFloatVector(rayDir[0], rayDir[1], rayDir[2])

        #        Create an empty MFloatPoint to receive the hit point from the call.
        hitPoint = om.MFloatPoint()

        #        Set up a variable for each remaining parameter in the
        #        MFnMesh::closestIntersection call. We could have supplied these as
        #        literal values in the call, but this makes the example more readable.
        sortIds = False
        maxDist = 10.0
        bothDirections = False
        noFaceIds = None
        noTriangleIds = None
        noAccelerator = None
        noHitParam = None
        noHitFace = None
        noHitTriangle = None
        noHitBary1 = None
        noHitBary2 = None

        #        Get the closest intersection.
        gotHit = meshFn.closestIntersection(
                raySource, rayDirection,
                noFaceIds, noTriangleIds,
                sortIds, om.MSpace.kWorld, maxDist, bothDirections,
                noAccelerator,
                hitPoint,
                noHitParam, noHitFace, noHitTriangle, noHitBary1, noHitBary2
        )

        #        Return the intersection as a Pthon list.
        if gotHit:
                return [hitPoint.x, hitPoint.y, hitPoint.z]
        else:
                return None
                
meshName=ls(sl=1, fl=1)
meshName=meshName[0]
raySource=[1, 1, 1]
rayDir=[1, 1, 1]
getsomething=findMeshIntersection(meshName, raySource, rayDir)
print getsomething     











import maya.OpenMaya as om

from pymel.core import *


def findMeshIntersection(meshName, raySource, rayDir):
        #        Create an empty selection list.
        selectionList = om.MSelectionList()

        #        Put the mesh's name on the selection list.
        selectionList.add(meshName)

        #        Create an empty MDagPath object.
        meshPath = om.MDagPath()

        #        Get the first item on the selection list (which will be our mesh)
        #        as an MDagPath.
        selectionList.getDagPath(0, meshPath)

        #        Create an MFnMesh functionset to operate on the node pointed to by
        #        the dag path.
        meshFn = om.MFnMesh(meshPath)

        #        Convert the 'raySource' parameter into an MFloatPoint.
        raySource = om.MFloatPoint( meshName+".translateX", meshName+".translateY", meshName+".translateZ" )

        #        Convert the 'rayDir' parameter into an MVector.`
        #rayDirection = om.MFloatVector()
        rayDirection = om.MVector()
        #        Create an empty MFloatPoint to receive the hit point from the call.
        hitPoint = om.MFloatPoint()

        #        Set up a variable for each remaining parameter in the
        #        MFnMesh::closestIntersection call. We could have supplied these as
        #        literal values in the call, but this makes the example more readable.
        sortIds = False
        maxDist = 10.0
        bothDirections = False
        noFaceIds = None
        noTriangleIds = None
        noAccelerator = None
        noHitParam = None
        noHitFace = None
        noHitTriangle = None
        noHitBary1 = None
        noHitBary2 = None

        #        Get the closest intersection.
        gotHit = meshFn.closestIntersection(
                raySource, rayDirection,
                noFaceIds, noTriangleIds,
                sortIds, om.MSpace.kWorld, maxDist, bothDirections,
                noAccelerator,
                hitPoint,
                noHitParam, noHitFace, noHitTriangle, noHitBary1, noHitBary2
        )

        #        Return the intersection as a Pthon list.
        if gotHit:
                return [hitPoint.x, hitPoint.y, hitPoint.z]
        else:
                return None
                
meshName=ls(sl=1, fl=1)
meshName=meshName[0]
#raySource=[1, 1, 1]
#rayDir=[1, 1, 1]
getsomething=findMeshIntersection(meshName, raySource, rayDir)
print getsomething                












import maya.OpenMaya as om

from pymel.core import *


def findMeshIntersection(meshName, raySource, rayDir):
        #        Create an empty selection list.
        selectionList = om.MSelectionList()

        #        Put the mesh's name on the selection list.
        selectionList.add(meshName)

        #        Create an empty MDagPath object.
        meshPath = om.MDagPath()

        #        Get the first item on the selection list (which will be our mesh)
        #        as an MDagPath.
        selectionList.getDagPath(0, meshPath)

        #        Create an MFnMesh functionset to operate on the node pointed to by
        #        the dag path.
        meshFn = om.MFnMesh(meshPath)

        #        Convert the 'raySource' parameter into an MFloatPoint.
        raySource = om.MFloatPoint()

        #        Convert the 'rayDir' parameter into an MVector.`
        rayDirection = om.MFloatVector()
        #rayDirection = om.MVector()
        #        Create an empty MFloatPoint to receive the hit point from the call.
        hitPoint = om.MFloatPoint()

        #        Set up a variable for each remaining parameter in the
        #        MFnMesh::closestIntersection call. We could have supplied these as
        #        literal values in the call, but this makes the example more readable.
        sortIds = False
        maxDist = 10.0
        bothDirections = False
        noFaceIds = None
        noTriangleIds = None
        noAccelerator = None
        noHitParam = None
        noHitFace = None
        noHitTriangle = None
        noHitBary1 = None
        noHitBary2 = None

        #        Get the closest intersection.
        gotHit = meshFn.closestIntersection(
                raySource, rayDirection,
                noFaceIds, noTriangleIds,
                sortIds, om.MSpace.kWorld, maxDist, bothDirections,
                noAccelerator,
                hitPoint,
                noHitParam, noHitFace, noHitTriangle, noHitBary1, noHitBary2
        )

        #        Return the intersection as a Pthon list.
        if gotHit:
                return [hitPoint.x, hitPoint.y, hitPoint.z]
        else:
                return None
                
meshName=ls(sl=1, fl=1)
getValueX= xform(meshName[0], q=1, ws=1, t=1)
print getValueX
raySource=getValueX
#rayDir=[1, 1, 1]
getsomething=findMeshIntersection(meshName[0], raySource, rayDir)
print getsomething                           



meshName=ls(sl=1, fl=1)
for each in meshName:
    for item in each.face:
        newobject=ls(item)
        gotNormals=newobject[0].getNormal(space='preTransform')
        print gotNormals
        
        
        
import maya.OpenMaya as om

from pymel.core import *


def findMeshIntersection(meshName, raySource, rayDir):
        #        Create an empty selection list.
        selectionList = om.MSelectionList()

        #        Put the mesh's name on the selection list.
        selectionList.add(meshName)

        #        Create an empty MDagPath object.
        meshPath = om.MDagPath()

        #        Get the first item on the selection list (which will be our mesh)
        #        as an MDagPath.
        selectionList.getDagPath(0, meshPath)

        #        Create an MFnMesh functionset to operate on the node pointed to by
        #        the dag path.
        meshFn = om.MFnMesh(meshPath)

        #        Convert the 'raySource' parameter into an MFloatPoint.
        raySource = om.MFloatPoint()

        #        Convert the 'rayDir' parameter into an MVector.`
        rayDirection = om.MFloatVector()
        #rayDirection = om.MVector()
        #        Create an empty MFloatPoint to receive the hit point from the call.
        hitPoint = om.MFloatPoint()

        #        Set up a variable for each remaining parameter in the
        #        MFnMesh::closestIntersection call. We could have supplied these as
        #        literal values in the call, but this makes the example more readable.
        sortIds = False
        maxDist = 10.0
        bothDirections = False
        noFaceIds = None
        noTriangleIds = None
        noAccelerator = None
        noHitParam = None
        noHitFace = None
        noHitTriangle = None
        noHitBary1 = None
        noHitBary2 = None

        #        Get the closest intersection.
        gotHit = meshFn.closestIntersection(
                raySource, rayDirection,
                noFaceIds, noTriangleIds,
                sortIds, om.MSpace.kWorld, maxDist, bothDirections,
                noAccelerator,
                hitPoint,
                noHitParam, noHitFace, noHitTriangle, noHitBary1, noHitBary2
        )

        #        Return the intersection as a Pthon list.
        if gotHit:
                return [hitPoint.x, hitPoint.y, hitPoint.z]
        else:
                return None
                
meshName=ls(sl=1, fl=1)
for each in meshName:
    for item in each.vtx:
        gotNormals=item.getNormal(space='preTransform')
        getValueX= xform(meshName[0], q=1, ws=1, t=1)
        print gotNormals
        print getValueX
        raySource=getValueX
        rayDirection=gotNormals
        getsomething=findMeshIntersection(meshName[0], raySource, rayDirection)
        print getsomething       
        
        
        
        
        
        
        
        
        
meshName=ls(sl=1, fl=1)
moveTool=ls(getit[1])
for each in meshName:
    for eachFace in each.faces:
        select(ls(eachFace), r=1)
        getItems=cmds.polyListComponentConversion( ff=1, tv=1 )
        cmds.select(getItems)
        getItems=ls(sl=1, fl=1)
    findTransformX=[]
    findTransformY=[]
    findTransformZ=[] 
    for each in getItems:
        transform=xform(each, q=1, ws=1, t=1)
        findTransformX.append(transform[0])
        findTransformY.append(transform[1])
        findTransformZ.append(transform[2])
    getX=median_find(findTransformX)
    getY=median_find(findTransformY)
    getZ=median_find(findTransformZ)
    newnumbers=[getX, getY, getZ]   
    cmds.xform(moveTool, ws=1, t=(newnumbers[0], newnumbers[1], newnumbers[2]))



import maya.OpenMaya as om

from pymel.core import *


def findMeshIntersection(meshName, raySource, rayDir):
        #        Create an empty selection list.
        selectionList = om.MSelectionList()

        #        Put the mesh's name on the selection list.
        selectionList.add(meshName)

        #        Create an empty MDagPath object.
        meshPath = om.MDagPath()

        #        Get the first item on the selection list (which will be our mesh)
        #        as an MDagPath.
        selectionList.getDagPath(0, meshPath)

        #        Create an MFnMesh functionset to operate on the node pointed to by
        #        the dag path.
        meshFn = om.MFnMesh(meshPath)

        #        Convert the 'raySource' parameter into an MFloatPoint.
        raySource = om.MFloatPoint()

        #        Convert the 'rayDir' parameter into an MVector.`
        rayDirection = om.MFloatVector()
        #rayDirection = om.MVector()
        #        Create an empty MFloatPoint to receive the hit point from the call.
        hitPoint = om.MFloatPoint()

        #        Set up a variable for each remaining parameter in the
        #        MFnMesh::closestIntersection call. We could have supplied these as
        #        literal values in the call, but this makes the example more readable.
        sortIds = False
        maxDist = 50.0
        bothDirections = 1
        noFaceIds = None
        noTriangleIds = None
        noAccelerator = None
        noHitParam = None
        noHitFace = None
        noHitTriangle = None
        noHitBary1 = None
        noHitBary2 = None

        #        Get the closest intersection.
        gotHit = meshFn.closestIntersection(
                raySource, rayDirection,
                noFaceIds, noTriangleIds,
                sortIds, om.MSpace.kWorld, maxDist, bothDirections,
                noAccelerator,
                hitPoint,
                noHitParam, noHitFace, noHitTriangle, noHitBary1, noHitBary2
        )

        #        Return the intersection as a Pthon list.
        if gotHit:
                return [hitPoint.x, hitPoint.y, hitPoint.z]
        else:
                return None


def median_find(lst):
    even = (0 if len(lst) % 2 else 1) + 1
    half = (len(lst) - 1) / 2
    mysum= sum(sorted(lst)[half:half + even]) / float(even)
    return mysum

              
meshName=ls(sl=1, fl=1)
moveTool=ls(getit[1])
for each in meshName:
    for eachFace in each.faces:
        select(ls(eachFace), r=1)
        getItems=cmds.polyListComponentConversion( ff=1, tv=1 )
        cmds.select(getItems)
        getItems=ls(sl=1, fl=1)
    findTransformX=[]
    findTransformY=[]
    findTransformZ=[] 
    for each in getItems:
        transform=xform(each, q=1, ws=1, t=1)
        findTransformX.append(transform[0])
        findTransformY.append(transform[1])
        findTransformZ.append(transform[2])
    getX=median_find(findTransformX)
    getY=median_find(findTransformY)
    getZ=median_find(findTransformZ)
    newnumbers=[getX, getY, getZ]   
    cmds.xform(moveTool, ws=1, t=(newnumbers[0], newnumbers[1], newnumbers[2]))

          

for each in meshName:
    select(getFace, r=1)
    getItems=cmds.polyListComponentConversion( ff=1, tv=1 )
    cmds.select(getItems)
    getItems=ls(sl=1, fl=1)
findTransformX=[]
findTransformY=[]
findTransformZ=[] 
for each in getItems:
    transform=xform(each, q=1, ws=1, t=1)
    print transform
    findTransformX.append(transform[0])
    findTransformY.append(transform[1])
    findTransformZ.append(transform[2])
getX=median_find(findTransformX)
getY=median_find(findTransformY)
getZ=median_find(findTransformZ)+1
newnumbers=[getX, getY, getZ]   
print newnumbers
cmds.xform(moveTool, ws=1, t=(newnumbers[0], newnumbers[1], newnumbers[2]))
print newnumbers
printget=getit[0].intersect(newnumbers, 2, tolerance=1e-10, space='object')
print printget
        
        
    for item in each.vtx:
        gotNormals=item.getNormal(space='preTransform')
        getValueX=xform(meshName[0], q=1, ws=1, t=1)
        raySource=getValueX
        rayDirection=gotNormals
        getsomething=findMeshIntersection(meshName[0], raySource, getDirection)


meshName=ls(sl=1, fl=1)
moveTool=ls(meshName[1])
mainMesh=ls(meshName[0])
for each in mainMesh:
    for indexFace, faceItem in enumerate(each.face):
        gotNormals=each.getPolygonNormal(indexFace, space='preTransform')
        print gotNormals    
    for eachFace in each.faces:
        select(ls(eachFace), r=1)
        getItems=cmds.polyListComponentConversion( ff=1, tv=1 )
        cmds.select(getItems)
        getItems=ls(sl=1, fl=1)
    findTransformX=[]
    findTransformY=[]
    findTransformZ=[] 
    for each in getItems:
        transform=xform(each, q=1, ws=1, t=1)
        findTransformX.append(transform[0])
        findTransformY.append(transform[1])
        findTransformZ.append(transform[2])
    getX=median_find(findTransformX)
    getY=median_find(findTransformY)
    getZ=median_find(findTransformZ)
    newnumbers=[getX, getY, getZ]   
    cmds.xform(moveTool, ws=1, t=(newnumbers[0], newnumbers[1], newnumbers[2])








from pymel.core import *
import maya.OpenMaya as om


def median_find(lst):
    even = (0 if len(lst) % 2 else 1) + 1
    half = (len(lst) - 1) / 2
    mysum= sum(sorted(lst)[half:half + even]) / float(even)
    return mysum

def findMeshIntersection(meshName, raySource, rayDir):
        #        Create an empty selection list.
        selectionList = om.MSelectionList()

        #        Put the mesh's name on the selection list.
        selectionList.add(meshName)

        #        Create an empty MDagPath object.
        meshPath = om.MDagPath()

        #        Get the first item on the selection list (which will be our mesh)
        #        as an MDagPath.
        selectionList.getDagPath(0, meshPath)

        #        Create an MFnMesh functionset to operate on the node pointed to by
        #        the dag path.
        meshFn = om.MFnMesh(meshPath)

        #        Convert the 'raySource' parameter into an MFloatPoint.
        raySource = om.MFloatPoint()

        #        Convert the 'rayDir' parameter into an MVector.`
        rayDirection = om.MFloatVector()
        #rayDirection = om.MVector()
        #        Create an empty MFloatPoint to receive the hit point from the call.
        hitPoint = om.MFloatPoint()

        #        Set up a variable for each remaining parameter in the
        #        MFnMesh::closestIntersection call. We could have supplied these as
        #        literal values in the call, but this makes the example more readable.
        sortIds = False
        maxDist = 50.0
        bothDirections = 1
        noFaceIds = None
        noTriangleIds = None
        noAccelerator = None
        noHitParam = None
        noHitFace = None
        noHitTriangle = None
        noHitBary1 = None
        noHitBary2 = None

        #        Get the closest intersection.
        gotHit = meshFn.closestIntersection(
                raySource, rayDirection,
                noFaceIds, noTriangleIds,
                sortIds, om.MSpace.kWorld, maxDist, bothDirections,
                noAccelerator,
                hitPoint,
                noHitParam, noHitFace, noHitTriangle, noHitBary1, noHitBary2
        )

        #        Return the intersection as a Pthon list.
        if gotHit:
                return [hitPoint.x, hitPoint.y, hitPoint.z]
        else:
                return None


meshName=ls(sl=1, fl=1)

mainMesh=ls(meshName[0])
for each in mainMesh:
    for indexFace, faceItem in enumerate(each.face):
        gotNormals=each.getPolygonNormal(indexFace, space='preTransform')
        print gotNormals    
    for eachFace in each.faces:
        select(ls(eachFace), r=1)
        getItems=cmds.polyListComponentConversion( ff=1, tv=1 )
        cmds.select(getItems)
        getItems=ls(sl=1, fl=1)
    findTransformX=[]
    findTransformY=[]
    findTransformZ=[] 
    for each in getItems:
        transform=xform(each, q=1, ws=1, t=1)
        findTransformX.append(transform[0])
        findTransformY.append(transform[1])
        findTransformZ.append(transform[2])
    getX=median_find(findTransformX)
    getY=median_find(findTransformY)
    getZ=median_find(findTransformZ)
    newnumbers=[getX, getY, getZ] 
    
    

    raySource=newnumbers
    rayDirection=gotNormals
    getsomething=findMeshIntersection(meshName[0], raySource, rayDirection)
    print getsomething       
    
    
    
    
    
from pymel.core import *
import maya.OpenMaya as om


def median_find(lst):
    even = (0 if len(lst) % 2 else 1) + 1
    half = (len(lst) - 1) / 2
    mysum= sum(sorted(lst)[half:half + even]) / float(even)
    return mysum

def findMeshIntersection(meshName, raySource, rayDir):
        #        Create an empty selection list.
        selectionList = om.MSelectionList()

        #        Put the mesh's name on the selection list.
        selectionList.add(meshName)

        #        Create an empty MDagPath object.
        meshPath = om.MDagPath()

        #        Get the first item on the selection list (which will be our mesh)
        #        as an MDagPath.
        selectionList.getDagPath(0, meshPath)

        #        Create an MFnMesh functionset to operate on the node pointed to by
        #        the dag path.
        meshFn = om.MFnMesh(meshPath)

        #        Convert the 'raySource' parameter into an MFloatPoint.
        raySource = om.MFloatPoint()

        #        Convert the 'rayDir' parameter into an MVector.`
        rayDirection = om.MFloatVector()
        #rayDirection = om.MVector()
        #        Create an empty MFloatPoint to receive the hit point from the call.
        hitPoint = om.MFloatPoint()

        #        Set up a variable for each remaining parameter in the
        #        MFnMesh::closestIntersection call. We could have supplied these as
        #        literal values in the call, but this makes the example more readable.
        sortIds = False
        maxDist = 50.0
        bothDirections = 1
        noFaceIds = None
        noTriangleIds = None
        noAccelerator = None
        noHitParam = None
        noHitFace = None
        noHitTriangle = None
        noHitBary1 = None
        noHitBary2 = None

        #        Get the closest intersection.
        gotHit = meshFn.closestIntersection(
                raySource, rayDirection,
                noFaceIds, noTriangleIds,
                sortIds, om.MSpace.kWorld, maxDist, bothDirections,
                noAccelerator,
                hitPoint,
                noHitParam, noHitFace, noHitTriangle, noHitBary1, noHitBary2
        )

        #        Return the intersection as a Pthon list.
        if gotHit:
                return [hitPoint.x, hitPoint.y, hitPoint.z]
        else:
                return None



def getfaceNormals(indexFace, each):
    gotNormals=each.getPolygonNormal(indexFace, space='preTransform')
    return gotNormals

def getlocation(eachFace):
    select(ls(eachFace), r=1)
    getItems=cmds.polyListComponentConversion( ff=1, tv=1 )
    cmds.select(getItems)
    getItems=ls(sl=1, fl=1)
    findTransformX=[]
    findTransformY=[]
    findTransformZ=[] 
    for item in getItems:
        transform=xform(item, q=1, ws=1, t=1)
        findTransformX.append(transform[0])
        findTransformY.append(transform[1])
        findTransformZ.append(transform[2])
    getX=median_find(findTransformX)
    getY=median_find(findTransformY)
    getZ=median_find(findTransformZ)
    newnumbers=[getX, getY, getZ] 
    return newnumbers


meshName=ls(sl=1, fl=1)
mainMesh=ls(meshName[0])
for each in mainMesh: 
    for indexFace, faceItem in enumerate(each.face):
        gotNormals=each.getPolygonNormal(indexFace, space='preTransform')  
        rayDirection=gotNormals
    for eachFace in each.faces:
        getMyStartpoint=getlocation(eachFace)
        raySource=getMyStartpoint
        getsomething=findMeshIntersection(meshName[0], raySource, rayDirection)
        print getsomething       
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
from pymel.core import *
import maya.OpenMaya as om


def median_find(lst):
    even = (0 if len(lst) % 2 else 1) + 1
    half = (len(lst) - 1) / 2
    mysum= sum(sorted(lst)[half:half + even]) / float(even)
    return mysum

def findMeshIntersection(meshName, raySource, rayDir):
        #        Create an empty selection list.
        selectionList = om.MSelectionList()

        #        Put the mesh's name on the selection list.
        selectionList.add(meshName)

        #        Create an empty MDagPath object.
        meshPath = om.MDagPath()

        #        Get the first item on the selection list (which will be our mesh)
        #        as an MDagPath.
        selectionList.getDagPath(0, meshPath)

        #        Create an MFnMesh functionset to operate on the node pointed to by
        #        the dag path.
        meshFn = om.MFnMesh(meshPath)

        #        Convert the 'raySource' parameter into an MFloatPoint.
        raySource = om.MFloatPoint()

        #        Convert the 'rayDir' parameter into an MVector.`
        rayDirection = om.MFloatVector()
        #rayDirection = om.MVector()
        #        Create an empty MFloatPoint to receive the hit point from the call.
        hitPoint = om.MFloatPoint()

        #        Set up a variable for each remaining parameter in the
        #        MFnMesh::closestIntersection call. We could have supplied these as
        #        literal values in the call, but this makes the example more readable.
        sortIds = False
        maxDist = 50.0
        bothDirections = 1
        noFaceIds = None
        noTriangleIds = None
        noAccelerator = None
        hitPoint = None
        noHitParam = None
        noHitFace = None
        noHitTriangle = None
        noHitBary1 = None
        noHitBary2 = None
        atolerance = 1e-6
        ReturnStatus = False

        #        Get the closest intersection.
        gotHit = meshFn.allIntersections(
                raySource, rayDirection,
                noFaceIds, noTriangleIds,
                sortIds, om.MSpace.kWorld, maxDist, bothDirections,
                noAccelerator,
                hitPoint,
                noHitParam, noHitFace, noHitTriangle, noHitBary1, noHitBary2, atolerance, ReturnStatus
        )

        #        Return the intersection as a Pthon list.
        if gotHit:
                return [hitPoint.x, hitPoint.y, hitPoint.z]
        else:
                return None



def getfaceNormals(indexFace, each):
    gotNormals=each.getPolygonNormal(indexFace, space='preTransform')
    return gotNormals


from pymel.core import *

selObj=cmds.ls(sl=1, fl=1, sn=1)
for each in selObj:
    getChild=listRelatives(each, ad=1, f=1, typ="clusterHandle")
    cmds.select(getChild)








selObj=cmds.ls(sl=1, fl=1)
parentObj=selObj[0]
childrenObj=selObj[1]
getparentObj=cmds.listRelatives(parentObj, c=1)
getchildObj=cmds.listRelatives(childrenObj, c=1)
for parentItem, childItem in map(None, getparentObj,getchildObj):
    cmds.select(parentItem)
    cmds.select(childItem, add=1)
    cmds.blendShape(n=parentItem+"_BShape", w=(0, 1.0))




getTopOpenGuides=cmds.ls(sl=1, fl=1)
for each in getTopOpenGuides:#get point values to build curve
    transformWorldMatrix = cmds.xform(each, q=True, wd=1, sp=True)  
    values.append(transformWorldMatrix)
cmds.curve(n=name, d=1, p=values)    

getTopOpenGuides=cmds.ls(sl=1, fl=1)
for each in getTopOpenGuides:#get point values to build curve
    transformWorldMatrix = cmds.xform(each, q=True, wd=1, sp=True)  
    values.append(transformWorldMatrix)
cmds.curve(n=name, d=1, p=values)





selObj=cmds.ls(sl=1, fl=1)
for each in selObj:
    getListAttr=listAttr (each, w=1, a=1, s=1, u=1)
    for eachattr in getListAttr:
        try:
            ls_str=cmds.listConnections(each+"."+eachattr, d=0, s=1, c=1)
        except:
            pass
        if ls_str:
            for eachsource in ls_str:
                print eachsource+ " source"
                try:
                    dn_str=cmds.listConnections(eachsource, s=0, d=1, c=1, p=1)
                except:
                    pass
                if dn_str:
                    for eachdestination in dn_str:
                        print eachdestination+ " destination from the source"


selObj=cmds.ls(sl=1, fl=1)
for each in selObj:
    try:
        ls_str=cmds.listConnections(each, d=0, s=1, p=1, sh=1)
        for eachsource in ls_str:
            downStrDest=cmds.connectionInfo(eachsource, dfs=1)
            print eachsource +" ---> "+downStrDest[0]
    except:
        pass


selObj=cmds.ls(sl=1, fl=1)
deformerTypes=["cluster", "skinCluster", "*cache*", "*Cache*", "mugginsCacheDeformer", "AlembicNode", ]
for each in selObj:
    for eachDefType in deformerTypes:
        try:
            ls_str=cmds.listConnections(each, d=0, s=1, p=1, sh=1, type=eachDefType)
            for eachsource in ls_str:
                downStrDest=cmds.connectionInfo(eachsource, dfs=1)
                print eachsource +" ---> "+downStrDest[0]
        except:
            pass



selObj=cmds.ls(sl=1, fl=1)
deformerTypes=["mugginsCacheDeformer", "AlembicNode"]
for each in selObj:
    try:
        ls_str=cmds.listConnections(each, d=0, s=1, p=1, sh=1)
        for eachsource in ls_str:
            if cmds.nodeType(cmds.ls(eachsource.split(".")[0]), i=1)[0]=="geometryFilter" and "tweak" not in eachsource:
                downStrDest=cmds.connectionInfo(eachsource, dfs=1)
                print eachsource +" ---> "+downStrDest[0]
    except:
        pass


selObj=cmds.ls(sl=1, fl=1)
pluginDeformerTypes=["AlembicNode"]
filterNode=["geometryFilter"]
exempt=["tweak"]
for each in selObj:
    try:
        ls_str=cmds.listConnections(each, d=0, s=1, p=1, sh=1)
        for eachsource in ls_str:
            getInputDef=[(eachConnected) for eachConnected in cmds.nodeType(cmds.ls(eachsource.split(".")[0]), i=1) for eachFilter in filterNode for eachExempt in exempt if eachConnected ==eachFilter and eachExempt not in eachsource] 
            getpluggedDefItem=[(eachConnected) for eachConnected in cmds.nodeType(cmds.ls(eachsource.split(".")[0]), i=1) for pluginDeformerTypes in deformerTypes if eachConnected ==pluggedDefItem]
            if getInputDef:
                downStrDest=cmds.connectionInfo(eachsource, dfs=1)
                print eachsource +" ---> "+downStrDest[0]
                print getInputDef
            elif getpluggedDefItem:
                downStrDest=cmds.connectionInfo(eachsource, dfs=1)
                print eachsource +" ---> "+downStrDest[0]
                print getpluggedDefItem
    except:
        pass



selObj=cmds.ls(sl=1, fl=1)
pluginTypes=["AlembicNode"]
filterNode=["geometryFilter"]
exempt=["tweak"]
for each in selObj:
    try:
        ls_str=cmds.listConnections(each, d=0, s=1, p=1, sh=1)     
        for eachsource in ls_str:
            getInputDef=[(eachConnected) for eachConnected in cmds.nodeType(cmds.ls(eachsource.split(".")[0]), i=1) for eachFilter in filterNode for eachExempt in exempt if eachConnected==eachFilter and eachExempt not in eachsource] 
            getpluggedDefItem=[(eachConnected) for eachConnected in cmds.nodeType(cmds.ls(eachsource.split(".")[0]), i=1) for pluginTypes in deformerTypes if eachConnected ==pluggedDefItem]
            if getInputDef:
                downStrDest=cmds.connectionInfo(eachsource, dfs=1)
                print eachsource +" ---> "+downStrDest[0]
                print getInputDef
            elif getpluggedDefItem:
                downStrDest=cmds.connectionInfo(eachsource, dfs=1)
                print eachsource +" ---> "+downStrDest[0]
                print getpluggedDefItem
    except:
        pass


selObj=cmds.ls(sl=1, fl=1)
attrValBucket=[]
for each in selObj:        
    getListedAttr=[(attrib) for attrib in listAttr (each, w=1, a=1, s=1) if "solverDisplay" not in attrib]
    for eachAttribute in getListedAttr:
        print each+"."+eachAttribute
        try:
            getKeyAttr=cmds.getAttr(each+"."+eachAttribute)
            print getKeyAttr
        except:
            print each+"."+eachAttribute+" cannot be accessed"




selObj=cmds.ls(sl=1, fl=1)
filterNode=["animCurve"]
attrValBucket=[]
for each in selObj:        
    getListedAttr=[(attrib) for attrib in listAttr (each, w=1, a=1, s=1) if "solverDisplay" not in attrib]
    for eachAttribute in getListedAttr:
        ls_str=cmds.listConnections(each, d=0, s=1, p=1, sh=1)
for eachsource in ls_str:
    getInputDef=[(eachConnected) for eachConnected in cmds.nodeType(cmds.ls(eachsource.split(".")[0]), i=1) for eachFilter in filterNode if eachConnected==eachFilter] 
    if getInputDef:
        downStrDest=cmds.connectionInfo(eachsource, dfs=1)
        print eachsource +" ---> "+downStrDest[0]



selObj=cmds.ls(sl=1, fl=1)
filterNode=["animCurve"]
attrValBucket=[]
for each in selObj:        
    getListedAttr=[(attrib) for attrib in listAttr (each, w=1, a=1, s=1) if "solverDisplay" not in attrib]
    for eachAttribute in getListedAttr:
        ls_str=cmds.listConnections(each, d=0, s=1, p=1, sh=1)
for eachsource in ls_str:
    getKeyNode=cmds.ls(eachsource.split(".")[0])[0]
    print getKeyNode
    getListedAttr=[(attrib) for attrib in listAttr (getKeyNode, w=1, a=1, s=1,u=1)]
    for listedAttr in getListedAttr:
        print listedAttr


selObj=cmds.ls(sl=1, fl=1)
for each in selObj:  
    getit=cmds.findKeyframe(each, curve=True) 
for eachKeyCurve in getit:
    getthis=cmds.findKeyframe(eachKeyCurve, time=(0,25), which="next" )
    print getthis



selObj=cmds.ls(sl=1, fl=1)
for each in selObj:  
    getCurve=[(item.split("_")[-1:]) for item in cmds.findKeyframe(each, curve=True)]
    for eachKeyCurve in getCurve:
        print each, eachKeyCurve
        getthis=cmds.keyframe(each, attribute=eachKeyCurve, query=True, keyframeCount=True )
        print getthis




selObj=cmds.ls(sl=1, fl=1)
filterNode=["animCurve"]
for each in selObj:
    try:
        ls_str=cmds.listConnections(each, d=0, s=1, p=1, sh=1)
        for eachsource in ls_str:
            remove=each+"_"
            removeobj=eachsource.split(remove)[1]
            eachsource=removeobj.split(".")[0]
            print eachsource
            getListedAttr=[(attrib) for attrib in listAttr (each) if attrib==eachsource]
            print getListedAttr, eachsource
            getCurve=[(eachConnected) for eachConnected in cmds.nodeType(cmds.ls(eachsource.split(".")[0]), i=1) for eachFilter in filterNode if eachConnected==eachFilter]
            if getCurve:
                getthis=cmds.keyframe(each, attribute=eachsource, query=True, keyframeCount=True )
                #getthis=cmds.findKeyframe(eachsource, time=(0,25), which="next" )
                print getthis
    except:
        pass



selObj=cmds.ls(sl=1, fl=1)
filterNode=["animCurve"]
for each in selObj:
    try:
        ls_str=cmds.listConnections(each, d=0, s=1, p=1, sh=1)
        for eachsource in ls_str:
            remove=each+"_"
            removeobj=eachsource.split(remove)[1]
            eachsource=removeobj.split(".")[0]
            getListedAttr=[(attrib) for attrib in listAttr (each) if attrib==eachsource]         
            getthis=cmds.keyframe(each, attribute=getListedAttr[0], query=True, keyframeCount=True )
            print getthis
    except:
        pass




selObj=cmds.ls(sl=1, fl=1)
filterNode=["animCurve"]
for each in selObj:
    try:
        ls_str=cmds.listConnections(each, d=0, s=1, p=1, sh=1)
        print ls_str
        keepLS=[(eachConnected) for eachConnected in cmds.nodeType(ls_str[0].split(".")[0], i=1) for eachFilter in filterNode if eachConnected==eachFilter]
        if keepLS:
            for eachsource in ls_str:
                print eachsource
                remove=each+"_"
                removeobj=eachsource.split(remove)[1]
                eachsource=removeobj.split(".")[0]
                getListedAttr=[(attrib) for attrib in listAttr (each) if attrib==eachsource]         
                getthis=cmds.keyframe(each, attribute=getListedAttr[0], query=True, keyframeCount=True )
                print getthis
    except:
        pass


selObj=cmds.ls(sl=1, fl=1)
filterNode=["animCurve"]
for each in selObj:
    try:
        ls_str=cmds.listConnections(each, d=0, s=1, p=1, sh=1)
        keepLS=[(eachConnected) for eachConnected in cmds.nodeType(ls_str[0].split(".")[0], i=1) for eachFilter in filterNode if eachConnected==eachFilter]
        if keepLS:
            for eachsource in ls_str:
                remove=each+"_"
                removeobj=eachsource.split(remove)[1]
                eachsource=removeobj.split(".")[0]
                getListedAttr=[(attrib) for attrib in listAttr (each) if attrib==eachsource]         
                #getthis=cmds.keyframe(each, attribute=getListedAttr[0], query=True, keyframeCount=True )
                print getListedAttr[0]
                print cmds.keyframe(each, attribute=getListedAttr[0], time=(0,100), query=True, timeChange=True)
                print cmds.keyframe(each, attribute=getListedAttr[0], time=(0,100), query=True, valueChange=True)
    except:
        pass


selObj=cmds.ls(sl=1, fl=1)
filterNode=["animCurve"]
for each in selObj:
    try:
        ls_str=cmds.listConnections(each, d=0, s=1, p=1, sh=1)
        keepLS=[(eachConnected) for eachConnected in cmds.nodeType(ls_str[0].split(".")[0], i=1) for eachFilter in filterNode if eachConnected==eachFilter]
        if keepLS:
            for eachsource in ls_str:
                remove=each+"_"
                removeobj=eachsource.split(remove)[1]
                eachsource=removeobj.split(".")[0]
                getListedAttr=[(attrib) for attrib in listAttr (each) if attrib==eachsource]         
                attibute=getListedAttr[0]
                frames=cmds.keyframe(each, attribute=getListedAttr[0], time=(0,100), query=True, timeChange=True)
                values=cmds.keyframe(each, attribute=getListedAttr[0], time=(0,100), query=True, valueChange=True)
                print attibute
                for each, item in map(None, frames, values):
                    print each, item
    except:
        pass



selObj=cmds.ls(sl=1, fl=1)
filterNode=["animCurve"]
dirDict={}
for each in selObj:
    try:
        ls_str=cmds.listConnections(each, d=0, s=1, p=1, sh=1)
        keepLS=[(eachConnected) for eachConnected in cmds.nodeType(ls_str[0].split(".")[0], i=1) for eachFilter in filterNode if eachConnected==eachFilter]
        if keepLS:
            for eachsource in ls_str:
                remove=each+"_"
                removeobj=eachsource.split(remove)[1]
                eachsource=removeobj.split(".")[0]
                getListedAttr=[(attrib) for attrib in listAttr (each) if attrib==eachsource]         
                attibute=getListedAttr[0]
                frames=cmds.keyframe(each, attribute=getListedAttr[0], time=(0,100), query=True, timeChange=True)
                values=cmds.keyframe(each, attribute=getListedAttr[0], time=(0,100), query=True, valueChange=True)
                for each, item in map(None, frames, values):
                    makeDict={each:item}
                    dirDict.update(makeDict)                     
    except:
        pass



selObj=cmds.ls(sl=1, fl=1)
filterNode=["animCurve"]
dirDict={}
getStrtRange=cmds.playbackOptions(q=1, ast=1)#get framerange of scene to set keys in iteration 
getEndRange=cmds.playbackOptions(q=1, aet=1)#get framerange of scene to set keys in iteration 
for each in selObj:
    try:
        ls_str=cmds.listConnections(each, d=0, s=1, p=1, sh=1)
        keepLS=[(eachConnected) for eachConnected in cmds.nodeType(ls_str[0].split(".")[0], i=1) for eachFilter in filterNode if eachConnected==eachFilter]
        if keepLS:
            for eachsource in ls_str:
                remove=each+"_"
                removeobj=eachsource.split(remove)[1]
                eachsource=removeobj.split(".")[0]
                getListedAttr=[(attrib) for attrib in listAttr (each) if attrib==eachsource]         
                attibute=getListedAttr[0]
                frames=cmds.keyframe(each, attribute=getListedAttr[0], time=(getStrtRange,getEndRange), query=True, timeChange=True)
                values=cmds.keyframe(each, attribute=getListedAttr[0], time=(getStrtRange,getEndRange), query=True, valueChange=True)
                print attibute
                for eachframe, valueitem in map(None, frames, values):
                    makeDict={eachframe:valueitem}
                    print makeDict
                    dirDict.update(makeDict)                     
    except:
        pass



printFolder="//usr//people//elise-d//pSphere1_jnt.txt"
notAttr=["isHierarchicalConnection", "solverDisplay", "isHierarchicalNode", "publishedNodeInfo", "fieldScale_Position", "fieldScale", "fieldScale.fieldScale_Position"]    
selObj=cmds.ls(sl=1, fl=1)
for each in selObj:
    attribute_container=[]
    getListedAttr=[(attrib) for attrib in listAttr(each, k=1, s=1, iu=1, u=1, lf=1, m=0) for item in notAttr if item not in attrib]
    print getListedAttr     
    if os.path.exists(printFolder):
        pass
    else:
        print printFolder+"does not exist"
        pass 
    List = open(printFolder).readlines()
    for aline in List:
        getAttribute=aline.split(';')[0]
        attribute_container.append(getAttribute)        
        dirDict=aline.split(';')[1]
        for item in getListedAttr:
            if item==getAttribute:
                for key, value in dirDict.items():
                    value=int(value)
                    cmds.setKeyframe( each, t=[key], at=getAttribute, v=value )



# folderPath='\\'.printFolderjoin(printFolder.split("/")[:-1])+"\\"
import ast
printFolder="//usr//people//elise-d//pSphere1_jnt.txt"
notAttr=["isHierarchicalConnection", "solverDisplay", "isHierarchicalNode", "publishedNodeInfo", "fieldScale_Position", "fieldScale", "fieldScale.fieldScale_Position"]    
selObj=cmds.ls(sl=1, fl=1)
for each in selObj:
    attribute_container=[]
    getListedAttr=[(attrib) for attrib in listAttr(each, k=1, s=1, iu=1, u=1, lf=1, m=0) for item in notAttr if item not in attrib]
    print getListedAttr     
    if os.path.exists(printFolder):
        pass
    else:
        print printFolder+"does not exist"
        pass 
    List = open(printFolder).readlines()
    for aline in List:
        getAttribute=aline.split(';')[0]
        attribute_container.append(getAttribute)        
        dirDict=aline.split(';')[1]
        gethis=ast.literal_eval(dirDict)
        for item in getListedAttr:
            if item==getAttribute:
                for key, value in gethis.items():
                    value=int(value)
                    cmds.setKeyframe( each, t=[key], at=getAttribute, v=value )





#SAVE
fileName="//usr//people//elise-d//"

selObj=cmds.ls(sl=1, fl=1)
for each in selObj:
    fileName=fileName+str(each)+'.txt'    
    if "Windows" in OSplatform:    
        # folderPath='/'.join(fileName.split('/')[:-1])+"/"
        # printFolder=re.sub(r'/',r'\\', folderPath)       
        if not os.path.exists(fileName): os.makedirs(fileName) 
    if "Linux" in OSplatform:
        open(fileName, 'w')
    inp=open(fileName, 'w+')
    selObj=cmds.ls(sl=1, fl=1)
    filterNode=["animCurve"]
    dirDict={}
    getStrtRange=cmds.playbackOptions(q=1, ast=1)#get framerange of scene to set keys in iteration 
    getEndRange=cmds.playbackOptions(q=1, aet=1)#get framerange of scene to set keys in iteration 
    try:
        ls_str=cmds.listConnections(each, d=0, s=1, p=1, sh=1)
        keepLS=[(eachConnected) for eachConnected in cmds.nodeType(ls_str[0].split(".")[0], i=1) for eachFilter in filterNode if eachConnected==eachFilter]
        if keepLS:
            for eachsource in ls_str:
                remove=each+"_"
                removeobj=eachsource.split(remove)[1]
                eachsource=removeobj.split(".")[0]
                getListedAttr=[(attrib) for attrib in listAttr (each) if attrib==eachsource]         
                attibute=getListedAttr[0]
                frames=cmds.keyframe(each, attribute=getListedAttr[0], time=(getStrtRange,getEndRange), query=True, timeChange=True)
                values=cmds.keyframe(each, attribute=getListedAttr[0], time=(getStrtRange,getEndRange), query=True, valueChange=True)
                print attibute
                inp.write(str(attibute)+";")
                for eachframe, valueitem in map(None, frames, values):
                    #inp.write(str(eachframe)+":"+str(valueitem)+'\n')
                    makeDict={eachframe:valueitem}
                    print str(makeDict)
                    dirDict.update(makeDict)
                    #print dirDict
                inp.write(str(dirDict)+'\n')
                print "saved as "+fileName
        inp.close()  
    except:
        pass

#LOAD
# folderPath='\\'.printFolderjoin(printFolder.split("/")[:-1])+"\\"
import ast
printFolder="//usr//people//elise-d//pSphere1.txt"
notAttr=["isHierarchicalConnection", "solverDisplay", "isHierarchicalNode", "publishedNodeInfo", "fieldScale_Position", "fieldScale", "fieldScale.fieldScale_Position"]    
selObj=cmds.ls(sl=1, fl=1)
for each in selObj:
    attribute_container=[]
    getListedAttr=[(attrib) for attrib in listAttr(each, k=1, s=1, iu=1, u=1, lf=1, m=0) for item in notAttr if item not in attrib]     
    if os.path.exists(printFolder):
        pass
    else:
        print printFolder+"does not exist"
        pass 
    List = open(printFolder).readlines()
    for aline in List:
        getAttribute=aline.split(';')[0]
        attribute_container.append(getAttribute)        
        dirDict=aline.split(';')[1]
        gethis=ast.literal_eval(dirDict)
        print gethis
        for item in getListedAttr:
            if item==getAttribute:
                for key, value in gethis.items():
                    cmds.setKeyframe( each, t=key, at=getAttribute, v=value )



#select charInfo and then characterGeometryLoader
selObj=cmds.ls(sl=1, fl=1)

cmds.connectAttr(selObj[0]+".gglInSsceneShot", selObj[1]+".gglInSscene_shot", f=1)
cmds.connectAttr(selObj[0]+".gglInSbundle", selObj[1]+".gglInSbundle", f=1)
cmds.connectAttr(selObj[0]+".gglInSelement", selObj[1]+".gglInSelement", f=1)
cmds.connectAttr(selObj[0]+".gglInIversion", selObj[1]+".gglInIversion", f=1)
cmds.connectAttr(selObj[0]+".gglInSpackagePath", selObj[1]+".gglInSpackagePathOverride", f=1)

cmds.createNode("timeToUnitConversion")
cmds.connectAttr("time1.output", "timeToUnitConversion1.input", f=1)
cmds.connectAttr("timeToUnitConversion1.output", selObj[1]+".gglInFcurrentFrame", f=1)
cmds.setAttr(selObj[1]+".gglInBuseFurUVs", 1)
cmds.setAttr(selObj[1]+".gglInBuseFurModel", 1)
cmds.setAttr(selObj[1]+".gglInBdoWorldPosScale", 1)


#select charinfo and then dynamic loader
selObj=cmds.ls(sl=1, fl=1)

cmds.connectAttr(selObj[0]+".gglInSsceneShot", selObj[1]+".gglInSscene_shot", f=1)
cmds.connectAttr(selObj[0]+".gglInSbundle", selObj[1]+".gglInSbundle", f=1)
cmds.connectAttr(selObj[0]+".gglInSelement", selObj[1]+".gglInSelement", f=1)
cmds.connectAttr(selObj[0]+".gglInIversion", selObj[1]+".gglInIversion", f=1)
cmds.connectAttr(selObj[0]+".gglInSpackagePath", selObj[1]+".gglInSpackagePathOverride", f=1)


#select charinfo and verlet solver
selObj=cmds.ls(sl=1, fl=1)

cmds.connectAttr(selObj[0]+".gglInFgeoCacheStartFrame", selObj[1]+".gglInFsimStartFrame", f=1)
cmds.connectAttr(selObj[0]+".gglInFgeoCacheStartFrame", selObj[1]+".gglInFcacheStartFrame", f=1)
cmds.connectAttr(selObj[0]+".gglInFgeoCacheEndFrame", selObj[1]+".gglInFcacheEndFrame", f=1)
cmds.setAttr(selObj[0]+".gglInIinitConstraintIterations", 20)


#select Verlet
selObj=cmds.ls(sl=1, fl=1)
getStrtRange=cmds.playbackOptions(q=1, ast=1)#get framerange of scene to set keys in iteration 
cmds.setAttr(selObj[0]+".gglInFsimStartFrame", getStrtRange)

#select hairbuilder
selObj=cmds.ls(sl=1, fl=1)
cmds.setAttr(selObj[0]+".gglInFangularStiffness", 0.9)
cmds.setAttr(selObj[0]+".gglInFlinearStiffness", 1.6)
#add collision
cmds.setAttr(selObj[0]+".gglInBuseOldVertexCollisions", 1)
cmds.setAttr(selObj[0]+".gglInBhairToHairCollision", 1)




selObj=cmds.ls(sl=1, fl=1)
filterNode=["animCurve"]
dirDict={}
getStrtRange=cmds.playbackOptions(q=1, ast=1)#get framerange of scene to set keys in iteration 
getEndRange=cmds.playbackOptions(q=1, aet=1)#get framerange of scene to set keys in iteration 
for eachObj in selObj:
    #get children
    getChildren=cmds.listRelatives(eachObj, ad=1)
    for each in getChildren:
        try:
            #get plugs
            ls_str=cmds.listConnections(each, d=0, s=1, p=1, sh=1)
            #get connected only if they are anim curve nodes
            for eachsource in ls_str:
                keepLS=[(eachConnected) for eachConnected in cmds.nodeType(eachsource.split(".")[0], i=1) for eachFilter in filterNode if eachConnected==eachFilter]
                if len(keepLS)>0:
                    remove=each+"_"
                    print remove+" this is the name of what i want to remove"
                    removeobj=eachsource.split(remove)[1]
                    print removeobj+" this is the result of removing that thing I just said"
                    eachsource=removeobj.split(".")[0]
                    print eachsource+" this is the node I want"    
                    getListedAttr=[(attrib) for attrib in listAttr (each) if attrib==eachsource]    
                    print getListedAttr+" this is something i forgot"               
        except:
            pass 
                    attibrute=getListedAttr[0]
                    print attibrute+" isolated the first thing"
                    #get frames of the attribute
                    frames=cmds.keyframe(each, attribute=getListedAttr[0], time=(getStrtRange,getEndRange), query=True, timeChange=True)
                    print frames+" this is the frames"
                    #get values of the attributes
                    values=cmds.keyframe(each, attribute=getListedAttr[0], time=(getStrtRange,getEndRange), query=True, valueChange=True)
                    print values+" this is values"
                    #inp.write(str(attibute)+";")
                    for eachframe, valueitem in map(None, frames, values):
                        #inp.write(str(eachframe)+":"+str(valueitem)+'\n')
                        makeDict={eachframe:valueitem}
                        print str(makeDict)
                        dirDict.update(makeDict)
                        #print dirDict
                    #inp.write(str(dirDict)+'\n')
                    print dirDict
                    print "saved as "+fileName
        except:
            pass


selObj=cmds.ls(sl=1, fl=1)
filterNode=["animCurve"]
dirDict={}
getStrtRange=cmds.playbackOptions(q=1, ast=1)#get framerange of scene to set keys in iteration 
getEndRange=cmds.playbackOptions(q=1, aet=1)#get framerange of scene to set keys in iteration 
for eachObj in selObj:
    print eachObj+" this is the parent"
    #get children
    getChildren=cmds.listRelatives(eachObj, ad=1)
    for each in getChildren:
        print each
        try:
            #get plugs
            ls_str=cmds.listConnections(each, d=0, s=1, p=1, sh=1)
            #get connected only if they are anim curve nodes
            for eachsource in ls_str:
                keepLS=[(eachConnected) for eachConnected in cmds.nodeType(eachsource.split(".")[0], i=1) for eachFilter in filterNode if eachConnected==eachFilter]
                if len(keepLS)>0:
                    remove=each+"_"
                    #print remove+" this is the name of what i want to remove"
                    removeobj=eachsource.split(remove)[1]
                    #print removeobj+" this is the result of removing that thing I just said"
                    eachsource=removeobj.split(".")[0]
                    #print eachsource+" this is the node I want"    
                    getListedAttr=[(attrib) for attrib in cmds.listAttr(each) if attrib==eachsource] 
                    attibrute=getListedAttr[0]
                    print attibrute
                    #print attibrute+" isolated the first thing"
                    #get frames of the attribute                
                    frames=cmds.keyframe(each, attribute=getListedAttr[0], time=(getStrtRange,getEndRange), query=True, timeChange=True)
                    #print frames                      
                    #get values of the attributes
                    values=cmds.keyframe(each, attribute=getListedAttr[0], time=(getStrtRange,getEndRange), query=True, valueChange=True)
                    #print values                 
                    #inp.write(str(attibute)+";")
                    for eachframe, valueitem in map(None, frames, values):
                        #print eachframe, valueitem
                        #inp.write(str(eachframe)+":"+str(valueitem)+'\n')
                        makeDict={eachframe:valueitem}
                        #print str(makeDict)
                        dirDict.update(makeDict)
                        #print dirDict
                    #inp.write(str(dirDict)+'\n')
                    print dirDict
                    #print "saved as "+fileName
        except:
            pass  

import ast
printFolder="/usr/people/elise-d/"
grabFileName="nurbsCircle1.txt"
printFolder=printFolder+grabFileName
notAttr=["isHierarchicalConnection", "solverDisplay", "isHierarchicalNode", "publishedNodeInfo", "fieldScale_Position", "fieldScale", "fieldScale.fieldScale_Position"]    
selObj=cmds.ls(sl=1, fl=1)
for each in selObj:
    attribute_container=[]
    getListedAttr=[(attrib) for attrib in listAttr(each, k=1, s=1, iu=1, u=1, lf=1, m=0) for item in notAttr if item not in attrib]     
    if os.path.exists(printFolder):
        pass
    else:
        print printFolder+"does not exist"
        pass 
    List = open(printFolder).readlines()
    for aline in List:
        if ";" in aline:
            getAttribute=aline.split(';')[0]
            print getAttribute
            attribute_container.append(getAttribute)        
            dirDict=aline.split(';')[1]
            if dirDict!="\n":
                print dirDict
                gethis=ast.literal_eval(dirDict)
                for key, value in gethis.items():
                    getAttribute=value[0]
                    for item in getListedAttr:
                        if item==value[0]:
                            cmds.setKeyframe( each, t=key, at=getAttribute, v=value[1] )                
            else:
                pass



import ast
printFolder="/usr/people/elise-d/"
grabFileName="nurbsCircle1.txt"
printFolder=printFolder+grabFileName
notAttr=["isHierarchicalConnection", "solverDisplay", "isHierarchicalNode", "publishedNodeInfo", "fieldScale_Position", "fieldScale", "fieldScale.fieldScale_Position"]    
selObj=cmds.ls(sl=1, fl=1)
for each in selObj:
    attribute_container=[]
    getListedAttr=[(attrib) for attrib in listAttr(each, k=1, s=1, iu=1, u=1, lf=1, m=0) for item in notAttr if item not in attrib]     
    if os.path.exists(printFolder):
        pass
    else:
        print printFolder+"does not exist"
        pass 
    List = open(printFolder).readlines()
    for aline in List:
        if ">>" in aline:
            getObj=aline.split('>>')[0]
        if ";" in aline:
            getAttribute=aline.split(';')[0]
            attribute_container.append(getAttribute)        
            dirDict=aline.split(';')[1]
            if dirDict!="\n":
                print getObj
                print getAttribute
                print dirDict
                gethis=ast.literal_eval(dirDict)
                for key, value in gethis.items():
                    cmds.setKeyframe( cmds.ls(getObj)[0], t=key, at=getAttribute, v=value )                
            else:
                pass



import ast
printFolder="/usr/people/elise-d/"
grabFileName="name01_guide.txt"
printFolder=printFolder+grabFileName
notAttr=["isHierarchicalConnection", "solverDisplay", "isHierarchicalNode", "publishedNodeInfo", "fieldScale_Position", "fieldScale", "fieldScale.fieldScale_Position"]    
selObj=cmds.ls(sl=1, fl=1)
for each in selObj:
    attribute_container=[]
    getListedAttr=[(attrib) for attrib in listAttr(each, k=1, s=1, iu=1, u=1, lf=1, m=0) for item in notAttr if item not in attrib]     
    if os.path.exists(printFolder):
        pass
    else:
        print printFolder+"does not exist"
        pass 
    List = open(printFolder).readlines()
    for aline in List:
        if ">>" in aline:
            getObj=aline.split('>>')[0]
            print getObj
            getExistantInfo=aline.split('>>')[1]
            if getExistantInfo!="\n":
                findAtt=getExistantInfo.split("<")
                for thing in findAtt:
                    getAnimDicts=thing.split(";")
                    print getAnimDicts

import ast
printFolder="/usr/people/elise-d/"
grabFileName="nurbsCircle1.txt"
printFolder=printFolder+grabFileName
notAttr=["isHierarchicalConnection", "solverDisplay", "isHierarchicalNode", "publishedNodeInfo", "fieldScale_Position", "fieldScale", "fieldScale.fieldScale_Position"]    
selObj=cmds.ls(sl=1, fl=1)
for each in selObj:
    attribute_container=[]
    getListedAttr=[(attrib) for attrib in listAttr(each, k=1, s=1, iu=1, u=1, lf=1, m=0) for item in notAttr if item not in attrib]     
    if os.path.exists(printFolder):
        pass
    else:
        print printFolder+"does not exist"
        pass 
    List = open(printFolder).readlines()
    for aline in List:
        if ">>" in aline:
            getObj=aline.split('>>')[0]
            getExistantInfo=aline.split('>>')[1]
            if getExistantInfo!="\n":
                findAtt=getExistantInfo.split("<")
                for thing in findAtt:
                    getAnimDicts=thing.split(";")
                    for eachctrl in xrange(len(getAnimDicts) - 1):
                        current_item, next_item = getAnimDicts[eachctrl], getAnimDicts[eachctrl + 1]
                        gethis=ast.literal_eval(next_item)
                        for key, value in gethis.items():
                            cmds.setKeyframe( cmds.ls(getObj)[0], t=key, at=current_item, v=value )                
            else:
                pass


selObj=cmds.ls(sl=1)
microLeadCurve=[selObj[0]]
CVbucketbuckList=[]
childControllers=selObj[1:]
for each in microLeadCurve:
    each=ls(each)[0]
    for eachCV, eachCtrlGro in map(None, each.cv, childControllers):
        CVbucketbuckList.append(eachCV)
microLeadCurve=ls(microLeadCurve)[0]
print microLeadCurve
print childControllers
print CVbucketbuckList
for eachCtrlGro in childControllers:
    try:
        print eachCtrlGro
        pgetCVpos=cmds.xform(eachCtrlGro, ws=1, q=1, t=1)
        #pgetCVpos=eachCtrlGro.getTranslation()
        print pgetCVpos
    except:
        pass
        getpoint=microLeadCurve.closestPoint(pgetCVpos, tolerance=0.001, space='preTransform')
        getParam=microLeadCurve.getParamAtPoint(getpoint, space='preTransform')
        select(eachCtrlGro, r=1)
        select(microLeadCurve, add=1)
        motionPath=cmds.pathAnimation(fractionMode=1, follow=1, followAxis="x", upAxis="y", worldUpType="vector", worldUpVector=[0, 1, 0], inverseUp=0, inverseFront=0, bank=0)        
        disconnectAttr(motionPath+"_uValue.output", motionPath+".uValue")
        getpth=str(motionPath)
        setAttr(motionPath+".fractionMode", False)
        setAttr(motionPath+".uValue", getParam) 





from pymel.core import *


getNames=ls(sl=1, fl=1)
getFirstGrp = getNames[0].split(".")[0]
getSecondGrp = getNames[-1:][0].split(".")[0]


firstList=[(each) for each in getNames if each.split(".")[0]==getFirstGrp]
secondList=[(each) for each in getNames if each.split(".")[0]==getSecondGrp]

cmds.select(firstList)
cmds.CreateCurveFromPoly()
getFirstCurve=cmds.ls(sl=1, fl=1)
getFirstCurveInfo=ls(sl=1, fl=1)
numberCV=getFirstCurveInfo[0].numCVs()
cmds.delete(getFirstCurve[0], ch=1)
print numberCV

cmds.select(secondList)
cmds.CreateCurveFromPoly()
getSecondCurve=cmds.ls(sl=1, fl=1)
getSecondCurveInfo=ls(sl=1, fl=1)
print getSecondCurveInfo[0].numCVs()
cmds.rebuildCurve(getSecondCurve[0], getFirstCurve[0], rt=2 )
getSecondCurve=cmds.ls(sl=1, fl=1)
getSecondCurveInfo=ls(sl=1, fl=1)
cmds.delete(getSecondCurve[0], ch=1)
#cmds.rebuildCurve(getSecondCurve[0], ch=0, rpo=1, rt=0, end=0, kr=2, kcp=0, kep=1, kt=1, s=numberCV, d=3, tol=1e-06)
print getSecondCurveInfo[0].numCVs()

cmds.select(cmds.ls(getFirstGrp)[0], r=1)
#cmds.select(getFirstCurve[0], r=1)
cmds.wire(w=getFirstCurve[0],  n="wire_def", gw=0, en=1.000000, ce=0.000000, li=0.000000, dds=[(0, 500)] )
#cmds.CreateWrap()

cmds.select(cmds.ls(getSecondGrp)[0], r=1)
#cmds.select(getSecondCurve[0], r=1)
cmds.wire(w=getSecondCurve[0], n="wire_def", gw=0, en=1.000000, ce=0.000000, li=0.000000, dds=[(0, 500)] )
#cmds.CreateWrap()

cmds.blendShape(getSecondCurve[0], getFirstCurve[0],w=(0, 1.0)) 





cmds.select( -r pPlane2 ;)
cmds.select -tgl pPlane1 ;
cmds.deformer(type="shrinkWrap", pPlane2;

cmds.setAttr(getShrink[0]+".shapePreservationEnable", 1)
cmds.setAttr(getShrink[0]+".shapePreservationSteps", 72)
cmds.setAttr(getShrink[0]+".shapePreservationReprojection", 1)
cmds.setAttr(getShrink[0]+".shapePreservationIterations", 1)
cmds.setAttr(getShrink[0]+".shapePreservationMethod", 0)
cmds.setAttr(getShrink[0]+".envelope", 1)
cmds.setAttr(getShrink[0]+".targetSmoothLevel", 1)
cmds.setAttr(getShrink[0]+".continuity", 1)
cmds.setAttr(getShrink[0]+".keepBorder", 0)
cmds.setAttr(getShrink[0]+".boundaryRule", 1)
cmds.setAttr(getShrink[0]+".keepHardEdge",0)
cmds.setAttr(getShrink[0]+".propagateEdgeHardness",0)
cmds.setAttr(getShrink[0]+".keepMapBorders",1)
cmds.setAttr(getShrink[0]+".projection",4)
cmds.setAttr(getShrink[0]+".closestIfNoIntersection",0)



myDict={
    ".shapePreservationEnable":1,
    ".shapePreservationSteps":72,
    ".shapePreservationReprojection";1,
    ".shapePreservationIterations":1,
    ".shapePreservationMethod":0,
    ".envelope":1,
    ".targetSmoothLevel"; 1,
    ".continuity":1,
    ".keepBorder":0,
    ".boundaryRule"; 1,
    ".keepHardEdge":0,
    ".propagateEdgeHardness":0,
    ".keepMapBorders":1,
    ".projection":4,
    ".closestIfNoIntersection":0,
    ,".closestIfNoIntersection":0 
    ,".reverse":0
    ,".bidirectional":0
    ,".boundingBoxCenter":1
    ,".axisReference":0 
    ,".alongX":1
    ,".alongY":1
    ,".alongZ":1
    ,".offset":0
    ,".targetInflation":0
    ,".falloff":0.3021390379
    ,".falloffIterations" 1
    ,".shapePreservationEnable" 1 
    ,".shapePreservationSteps" 72
    ,".shapePreservationIterations" 1 
    ,".shapePreservationReprojection" 1 
    ,".shapePreservationMethod" 0}



cmds.select(getFirstGrp, r=1)
cmds.select(getSecondGrp, add=1)
getShrink=cmds.deformer(getFirstGrp, n="newShrink", type="shrinkWrap")


cmds.connectAttr(getSecondGrp+".worldMesh[0]", getShrink[0]+".targetGeom", f=1)

myDict={".shapePreservationEnable":1, ".shapePreservationSteps":72, ".shapePreservationReprojection":1,".shapePreservationIterations":1,".shapePreservationMethod":0,".envelope":1,".targetSmoothLevel":1,".continuity":1,".keepBorder":0,".boundaryRule":1,".keepHardEdge":0,".propagateEdgeHardness":0,".keepMapBorders":1,".projection":4,".closestIfNoIntersection":0,".closestIfNoIntersection":0 ,".reverse":0,".bidirectional":0,".boundingBoxCenter":1,".axisReference":0 ,".alongX":1,".alongY":1,".alongZ":1,".offset":0,".targetInflation":0,".falloff":0.3021390379,".falloffIterations": 1,".shapePreservationEnable": 1 ,".shapePreservationSteps": 72,".shapePreservationIterations": 1 ,".shapePreservationReprojection": 1 ,".shapePreservationMethod": 0}

    
    
for key, value in myDict.items():
    cmds.setAttr(getShrink[0]+key, value)





getShrink=cmds.deformer(getFirstGrp, type="shrinkWrap")
cmds.connectAttr(getSecondGrp+".worldMesh[0]", getShrink[0]+".targetGeom", f=1)


myDict={
        ".shapePreservationEnable":1, 
        ".shapePreservationSteps":72, 
        ".shapePreservationReprojection":1,
        ".shapePreservationIterations":1,
        ".shapePreservationMethod":0,
        ".envelope":1,".targetSmoothLevel":1,
        ".continuity":1,".keepBorder":0,
        ".boundaryRule":1,".keepHardEdge":0,
        ".propagateEdgeHardness":0,
        ".keepMapBorders":1,
        ".projection":4,
        ".closestIfNoIntersection":0,
        ".closestIfNoIntersection":0 ,
        ".reverse":0,
        ".bidirectional":0,
        ".boundingBoxCenter":1,
        ".axisReference":0 ,
        ".alongX":1,
        ".alongY":1,
        ".alongZ":1,
        ".offset":0,
        ".targetInflation":0,
        ".falloff":0.3021390379,
        ".falloffIterations": 1,
        ".shapePreservationEnable": 1 ,
        ".shapePreservationSteps": 72,
        ".shapePreservationIterations": 1 ,
        ".shapePreservationReprojection": 1 ,
        ".shapePreservationMethod": 0
        }

for key, value in myDict.items():
    cmds.setAttr(getShrink[0]+key, value)
    print "set value for shrinkwrap"


getSel=cmds.ls(sl=1, fl=1)
edgeBucket=[]
if getSel:
    pass
else:
    print "You need to make a selection for this tool to operate on."
for each in getSel:
    getComponent = cmds.polyInfo(each, ve=True)
    getVerts=getComponent[0].split(':')[1]
    edgeCount=re.findall(r'\d+', getVerts)    
    edgeBucket.append(edgeCount[:2])
for items in edgeBucket:
    cmds.select("pPlane1.e["+item[0]+"]"}, r=1)
    cmds.select("pPlane1.e["+item[1]+"]"}, r=1)
    maya.mel.eval( 'rivet();' )    


getSel=cmds.ls(sl=1, fl=1)
edgeBucket=[]
if ".vtx[" in getSel[0]:
    pass
else:
    print "You need to make some vertex selections for this tool to operate on."
for each in getSel:
    getUVmap = cmds.polyListComponentConversion(each, fv=1, tuv=1)
    getCoords=cmds.polyEditUV(getUVmap, q=1)
    print getCoords


getSel=cmds.ls(sl=1, fl=1)
edgeBucket=[]
if ".vtx[" in getSel[0]:
    pass
else:
    print "You need to make some vertex selections for this tool to operate on."
for each in getSel:
    getObj=getSel[0].split('.')[0]
    getUVmap = cmds.polyListComponentConversion(each, fv=1, tuv=1)
    getCoords=cmds.polyEditUV(getUVmap, q=1)
    print getCoords
    getNew=cmds.spaceLocator(n=each+"_loc")
    cmds.select(each, r=1)
    cmds.select(getNew[0], add=1)
    buildConst=cmds.pointOnPolyConstraint(each, getNew[0], mo=0, offset=(0.0, 0.0, 0.0))
    cmds.setAttr(buildConst[0]+"."+getObj+"U0", getCoords[0])
    cmds.setAttr(buildConst[0]+"."+getObj+"V0", getCoords[1])    



getNames=cmds.ls(sl=1, fl=1)
for focusObj in getNames:
    getListedAttr=[(attrib) for attrib in cmds.listAttr (focusObj, c=1, iu=1, m=0) if "solverDisplay" not in attrib]
    for each in getListedAttr:
        if "inMesh" in each:
            print each
            findFact=cmds.listConnections(focusObj, s=1, d=0, p=1, sh=1)
            if findFact:
                getNewPlug=len(findFact)
                print findFact[0].split('[')[0]+"["+str(getNewPlug)+"]"


getNames=cmds.ls(sl=1, fl=1)
#"input[0].inputGeometry"
#upStreamSource="outputGeometry[0]"
inmeshs=["inputGeometry", "inMesh", "inputMesh", "basePoints", "input"]
upStreamSource=["outputGeometry", "outputGeometry[0]", "outMesh", "outputMesh", "worldMesh", "worldMesh[0]", "_outMesh", "output" ]
for focusObj in getNames:
    getListedAttr=[(attrib) for attrib in cmds.listAttr (focusObj, c=1, iu=1, m=0) for item in inmeshs if item ==attrib]
    for each in getListedAttr:
        getConnect=cmds.connectionInfo(focusObj+"."+each, sfd=1)
        if getConnect:
            pass
        else:
            print cmds.attributeQuery(each, node=focusObj, c=1)
            getGrp=cmds.listAttr (focusObj+"."+each, c=1, iu=1, m=0)
            for item in getGrp:
                if "." in item:
                    print item
                    print cmds.attributeQuery(item.split(".")[1], node=focusObj+"."+item.split(".")[0], c=1)



getNames=cmds.ls(sl=1, fl=1)
#"input[0].inputGeometry"
#upStreamSource="outputGeometry[0]"
inmeshs=["inputGeometry", "inMesh", "inputMesh", "basePoints", "input"]
outmeshs=["outputGeometry", "outputGeometry[0]", "outMesh", "outputMesh", "worldMesh", "worldMesh[0]", "_outMesh", "output" ]
for eachSelObj in getNames:
    getInPlug=[(attrib) for attrib in cmds.listAttr (eachSelObj, c=1, iu=1, m=0) for item in inmeshs if item ==attrib]
    for each in getInPlug:
        #getGrp=[(attrib) for attrib in cmds.listAttr (eachSelObj+"."+each, c=1, iu=1, m=0) for item in inmeshs if item ==attrib]
        getGrp=cmds.listAttr (eachSelObj+"."+each, c=1, iu=1, m=1)
        if getGrp !=None:
            print getGrp
            grab=[(item) for item in getGrp for eachinmeshs in inmeshs if item ==eachinmeshs]
            print grab
